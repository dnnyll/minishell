/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_redirections.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: daniefe2 <daniefe2@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/06 11:18:38 by daniefe2          #+#    #+#             */
/*   Updated: 2025/06/06 12:06:43 by daniefe2         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/*
** ============================================================================
** File: parser_redirections.c
**
** Description:
** This file is part of the parser module. Its main responsibility is to
** detect and extract input and output redirections from a list of tokens
** generated by the lexer.
**
** Functions:
** - detect_redirections: Scans a token list and identifies redirection operators
**   such as '<' and '>'. For each redirection found, it creates a t_redirect
**   node with the target filename and appends it to the appropriate list in
**   the current command structure.
**
** - append_to_redir_list: Helper function that appends a new redirection node
**   to the end of a linked list.
**
** This logic ensures that each command has a clear record of its associated
** input/output files before execution.
** ============================================================================
*/

// Append a new redirection node to the end of a redirection list
void	append_to_redir_list(t_redirect **list, t_redirect *new_node)
{
	if (!*list)
		*list = new_node; // If list is empty, start the list
	else
	{
		t_redirect *current = *list;
		while (current->next)
			current = current->next; // Traverse to the end of the list
		current->next = new_node; // Append the new node
	}
}

// Scan the token list and collect input/output redirections into the command struct
void	detect_redirections(t_token *head, t_command *cmd)
{
	t_token *temp = head;
	// Traverse the token list until we hit a PIPE or reach the end
	while (temp && temp->type != PIPE)
	{
		// Check if the current token is a redirection (any type) and the next token is a valid filename (WORD)
		if ((temp->type == REDIR_IN || temp->type == REDIR_OUT ||
			 temp->type == APPEND || temp->type == HEREDOC) &&
			temp->next && temp->next->type == WORD)
		{
			// Allocate memory for a new redirection node
			t_redirect *redir = malloc(sizeof(t_redirect));
			if (!redir)
				return; // Memory allocation failed; stop parsing redirections
			// Set the type of redirection: REDIR_IN, REDIR_OUT, APPEND, HEREDOC
			redir->type = temp->type;
			// Duplicate the filename or limiter string from the next token
			redir->file = ft_strdup(temp->next->value);
			// Initialize next to NULL; this will be appended to the appropriate list
			redir->next = NULL;
			// Append the redirection to the appropriate list
			// HEREDOC and REDIR_IN go to input list; REDIR_OUT and APPEND go to output list
			if (temp->type == REDIR_IN || temp->type == HEREDOC)
				append_to_redir_list(&cmd->redir_in, redir);
			else
				append_to_redir_list(&cmd->redir_out, redir);
			// Move ahead by two tokens: skip the redirection operator and the file/limiter
			temp = temp->next->next;
			continue; // Continue parsing the remaining tokens
		}
		// If not a redirection token, move to the next token
		temp = temp->next;
	}
}
